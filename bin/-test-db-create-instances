#!/usr/bin/env bash

# Starting in bash for now and then we can change it to python once the
# initial call works

set -o pipefail

logf() {
  printf "$1\n" "${@:2}" >&2
}

warnf() {
  logf "WARN: ${1}" "${@:2}"
}

infof() {
  logf "INFO: ${1}" "${@:2}"
}

errorf() {
  logf "ERROR: ${1}" "${@:2}"
  exit 1
}

while :
do
  case $1 in
    -l)
      long_output=true
      ;;
    *)
      break
  esac
  shift
done

test_db_not_online() {
  local instance_identifier=$1
  db_instance_status=$(aws rds describe-db-instances --db-instance-identifier "${instance_identifier}" \
                         | jq -r '.DBInstances[].DBInstanceStatus')
  if (( $? != 0 ))
  then
    warnf 'Failed to describe %s' "$identifier"
  fi
  [[ $db_instance_status != available ]]
}

describe_instance() {
  local instance_identifier=$1
  local jq_filter
  jq_filter='.DBInstances[]
             | {stable_address: "'"$stable_dns_name"'",
                address: .Endpoint.Address,
                identifier: .DBInstanceIdentifier,
                status: .DBInstanceStatus,
                master_username: .MasterUsername,
                master_password: "'"$master_password"'"}'
  if [[ $long_output == true ]] || [[ $2 == full ]]
  then
    jq_filter='.DBInstances[]'
  fi
  aws rds describe-db-instances --db-instance-identifier "${instance_identifier}" \
    | jq "$jq_filter"
}

instance_status() {
  local instance_identifier=$1
  describe_instance "${instance_identifier}" full | jq -r '.DBInstanceStatus'
}

create_test_instance() {
  local instance_identifier=$1
  local stable_dns_name="${instance_identifier}.db.test.stitchdata.com"
  local master_username=$STITCH_TAP_MSSQL_TEST_DATABASE_USER
  local master_password=$STITCH_TAP_MSSQL_TEST_DATABASE_PASSWORD

  printf 'instance_identifier: %s\n' "${instance_identifier}"
  source <(jq -r '.[] 
                    | select(.name == "'"${instance_identifier}"'")
                    | .properties
                    | to_entries[]
                    | "export \(.key)=\(.value)"' \
                      bin/testing-resources.json)
  
  printf 'Args: %s\n' "$engine" "$engine_version"

  if test_db_not_online "${instance_identifier}"
  then
    # Create instance if it's not already created
    if ! describe_instance "${instance_identifier}" >/dev/null
    then
      logf "Creating db instance %s" "${instance_identifier}"
      if ! aws --region us-east-1 \
           rds create-db-instance \
           --vpc-security-group-ids sg-089b5962b0c44592f \
           --db-instance-identifier "${instance_identifier}" \
           --db-instance-class db.m4.large \
           --engine "${engine}" \
           --engine-version "${engine_version}" \
           --allocated-storage 100 \
           --master-username "$master_username" \
           --master-user-password "$master_password" \
           --backup-retention-period 0 \
           --no-auto-minor-version-upgrade \
           --license-model license-included
      then
        errorf  "Failed to initiate creation of %s" "${instance_identifier}"
      fi
    fi
    # Wait for instance to be online
    while test_db_not_online "${instance_identifier}"
    do
      infof "Waiting for db instance %s to come up for %s seconds (current status: %s)" \
            "${instance_identifier}" \
            "$SECONDS" \
            "$(instance_status "${instance_identifier}")"
      sleep 30
    done
  fi

  # Upsert route53 entry
  actual_dns_name=$(describe_instance "${instance_identifier}" | jq -r '.address')
  change_batch='
  {
    "Comment": "'"${instance_identifier}"' deployment '"$(date -u)"'",
    "Changes": [
      {
        "Action": "UPSERT",
        "ResourceRecordSet": {
          "Name": "'"$stable_dns_name"'",
          "Type": "CNAME",
          "TTL": 300,
          "ResourceRecords": [
            {
              "Value": "'"$actual_dns_name"'"
            }
          ]
        }
      }
    ]
  }
  '
  if ! aws route53 change-resource-record-sets \
       --hosted-zone-id '/hostedzone/ZENICS0BKW1AD' \
       --change-batch "$change_batch"
  then
    errorf 'Failed to create DNS entry: %s' "$stable_dns_name"
  fi

  wait_time=600
  SECONDS=0
  while ! nslookup "$stable_dns_name" 8.8.8.8 \
      | grep -q -F -- 'canonical name ='
  do
    echo "Waiting for DNS cutover to take effect for ${SECONDS}s"
    sleep 30
    if (( wait_time < SECONDS ))
    then
      errorf 'DNS cutover failed to take effect in %d seconds.' "$SECONDS"
    fi
  done

  infof 'DB instance %s created' "${instance_identifier}"
  describe_instance "${instance_identifier}"
}

while read -r instance_identifier
do
  create_test_instance "$HOSTNAME-test-mssql-${instance_identifier}"
done < <(jq -r '.[].name' bin/testing-resources.json)

